<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Nexus Defense</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            color: #fff;
            position: fixed;
        }

        .game-container {
            position: relative;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0a;
            cursor: crosshair;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .top-ui {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(0, 255, 255, 0.1);
            padding: 10px 20px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .bottom-ui {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            pointer-events: auto;
        }

        .tower-btn, .speed-btn {
            padding: 12px 16px;
            background: linear-gradient(45deg, #1e3c72, #2a5298);
            border: 2px solid #00ffff;
            border-radius: 15px;
            color: #00ffff;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            min-width: 80px;
            text-align: center;
        }

        .tower-btn:hover, .speed-btn:hover {
            background: linear-gradient(45deg, #2a5298, #1e3c72);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
            transform: translateY(-2px);
        }

        .tower-btn.selected {
            background: linear-gradient(45deg, #ff6b6b, #ee5a6f);
            border-color: #ff6b6b;
            color: #fff;
        }

        .speed-btn.active {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            border-color: #4ecdc4;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            border: 2px solid #ff6b6b;
            backdrop-filter: blur(10px);
        }

        .game-over h2 {
            color: #ff6b6b;
            font-size: 32px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 107, 107, 0.8);
        }

        .game-over p {
            color: #00ffff;
            font-size: 18px;
            margin: 10px 0;
        }

        .restart-btn {
            margin-top: 20px;
            padding: 15px 30px;
            background: linear-gradient(45deg, #1e3c72, #2a5298);
            border: 2px solid #00ffff;
            border-radius: 10px;
            color: #00ffff;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .restart-btn:hover {
            background: linear-gradient(45deg, #2a5298, #1e3c72);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        .speed-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 5px;
            pointer-events: auto;
        }

        @media (max-width: 768px) {
            .top-ui {
                flex-direction: column;
                gap: 5px;
                padding: 5px 10px;
            }
            
            .stat {
                font-size: 12px;
            }
            
            .tower-btn, .speed-btn {
                padding: 10px 12px;
                font-size: 10px;
                min-width: 60px;
            }
            
            .speed-controls {
                top: 10px;
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div class="ui-overlay">
            <div class="top-ui">
                <div class="stat">üí∞ <span id="money">100</span></div>
                <div class="stat">‚ù§Ô∏è <span id="lives">20</span></div>
                <div class="stat">üåä Wave <span id="wave">1</span></div>
                <div class="stat">‚ö° Score <span id="score">0</span></div>
                <div class="stat">‚è±Ô∏è <span id="countdown">Ready</span></div>
            </div>

            <div class="speed-controls">
                <button class="speed-btn" data-speed="1">1x</button>
                <button class="speed-btn" data-speed="2">2x</button>
                <button class="speed-btn" data-speed="4">4x</button>
                <button class="speed-btn" data-speed="6">6x</button>
            </div>
            
            <div class="bottom-ui">
                <button class="tower-btn" data-tower="laser">
                    LASER<br>üí∞50
                </button>
                <button class="tower-btn" data-tower="plasma">
                    PLASMA<br>üí∞75
                </button>
                <button class="tower-btn" data-tower="ice">
                    ICE<br>üí∞60
                </button>
            </div>
        </div>
        
        <div id="gameOverScreen" class="game-over" style="display: none;">
            <h2>GAME OVER</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Wave Reached: <span id="finalWave">1</span></p>
            <button class="restart-btn" onclick="restartGame()">RESTART</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // „Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫Ë®≠ÂÆö
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // „Ç≤„Éº„É†Â§âÊï∞
        let money = 100;
        let lives = 20;
        let score = 0;
        let currentWave = 1;
        let waveCountdown = 180;
        let gameOver = false;
        let selectedTower = null;
        let frameCount = 0;
        let gameSpeed = 1;

        // „Ç≤„Éº„É†„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
        let towers = [];
        let enemies = [];
        let projectiles = [];
        let effects = [];
        let currentWaveEnemies = [];
        let enemySpawnIndex = 0;

        // ÁµåË∑ØÂÆöÁæ©
        const path = [
            {x: 50, y: canvas.height * 0.5},
            {x: canvas.width * 0.2, y: canvas.height * 0.5},
            {x: canvas.width * 0.2, y: canvas.height * 0.2},
            {x: canvas.width * 0.5, y: canvas.height * 0.2},
            {x: canvas.width * 0.5, y: canvas.height * 0.8},
            {x: canvas.width * 0.8, y: canvas.height * 0.8},
            {x: canvas.width * 0.8, y: canvas.height * 0.5},
            {x: canvas.width - 50, y: canvas.height * 0.5}
        ];

        // „Çø„ÉØ„Éº„Çø„Ç§„ÉóÂÆöÁæ©
        const towerTypes = {
            laser: {
                cost: 50,
                damage: 25,
                range: 120,
                fireRate: 30,
                color: '#ff6b6b',
                projectileSpeed: 8,
                type: 'laser'
            },
            plasma: {
                cost: 75,
                damage: 40,
                range: 100,
                fireRate: 45,
                color: '#4ecdc4',
                projectileSpeed: 6,
                type: 'plasma'
            },
            ice: {
                cost: 60,
                damage: 15,
                range: 110,
                fireRate: 20,
                color: '#74b9ff',
                projectileSpeed: 7,
                type: 'ice',
                slow: true
            }
        };

        // Êïµ„Çø„Ç§„ÉóÂÆöÁæ©
        const enemyTypes = {
            normal: {
                hp: 100,
                speed: 1.5,
                color: '#4ecdc4',
                reward: 10,
                size: 15
            },
            fast: {
                hp: 50,
                speed: 3,
                color: '#ff6b6b',
                reward: 15,
                size: 12
            },
            armor: {
                hp: 200,
                speed: 1,
                color: '#95a5a6',
                reward: 25,
                size: 18,
                armor: 0.5,
                laserWeak: true
            },
            stealth: {
                hp: 80,
                speed: 2,
                color: '#9b59b6',
                reward: 20,
                size: 13,
                stealth: true,
                alpha: 0.3
            },
            healer: {
                hp: 120,
                speed: 1.2,
                color: '#2ecc71',
                reward: 30,
                size: 16,
                healer: true
            },
            splitter: {
                hp: 60,
                speed: 1.8,
                color: '#e74c3c',
                reward: 15,
                size: 14,
                splitter: true
            },
            shield: {
                hp: 150,
                speed: 1.3,
                color: '#f39c12',
                reward: 20,
                size: 17,
                shield: true
            },
            teleport: {
                hp: 90,
                speed: 1.5,
                color: '#8e44ad',
                reward: 25,
                size: 14,
                teleport: true
            },
            boss: {
                hp: 1000,
                speed: 0.8,
                color: '#c0392b',
                reward: 100,
                size: 30,
                boss: true
            },
            rush: {
                hp: 70,
                speed: 1.5,
                color: '#e67e22',
                reward: 18,
                size: 13,
                rush: true
            },
            barrier: {
                hp: 80,
                speed: 1.4,
                color: '#3498db',
                reward: 22,
                size: 15,
                barrier: 100
            }
        };

        // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
        document.addEventListener('click', handleClick);
        document.addEventListener('touchstart', handleTouch);

        // „Çø„ÉØ„ÉºÈÅ∏Êäû
        document.querySelectorAll('.tower-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                selectedTower = btn.dataset.tower;
            });
        });

        // ÈÄüÂ∫¶Âà∂Âæ°
        document.querySelectorAll('.speed-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                gameSpeed = parseInt(btn.dataset.speed);
            });
        });

        // ÂàùÊúüÈÄüÂ∫¶Ë®≠ÂÆö
        document.querySelector('.speed-btn[data-speed="1"]').classList.add('active');

        function handleClick(e) {
            if (e.target.closest('.ui-overlay')) return;
            placeTower(e.clientX, e.clientY);
        }

        function handleTouch(e) {
            e.preventDefault();
            if (e.target.closest('.ui-overlay')) return;
            const touch = e.touches[0];
            placeTower(touch.clientX, touch.clientY);
        }

        function placeTower(x, y) {
            if (!selectedTower || gameOver) return;
            
            const towerType = towerTypes[selectedTower];
            if (money < towerType.cost) return;

            // ÁµåË∑Ø„ÇÑ„Çø„ÉØ„Éº„Å®„ÅÆÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
            if (isValidPlacement(x, y)) {
                towers.push({
                    x: x,
                    y: y,
                    type: selectedTower,
                    lastFire: 0,
                    target: null,
                    ...towerType
                });
                money -= towerType.cost;
                updateUI();
            }
        }

        function isValidPlacement(x, y) {
            const minDistance = 40;
            
            // ÁµåË∑Ø„Å®„ÅÆË∑ùÈõ¢„ÉÅ„Çß„ÉÉ„ÇØ
            for (let i = 0; i < path.length - 1; i++) {
                const dist = distanceToLineSegment(x, y, path[i], path[i + 1]);
                if (dist < minDistance) return false;
            }
            
            // ‰ªñ„ÅÆ„Çø„ÉØ„Éº„Å®„ÅÆË∑ùÈõ¢„ÉÅ„Çß„ÉÉ„ÇØ
            for (const tower of towers) {
                const dist = Math.sqrt((x - tower.x) ** 2 + (y - tower.y) ** 2);
                if (dist < minDistance) return false;
            }
            
            return true;
        }

        function distanceToLineSegment(px, py, line1, line2) {
            const A = px - line1.x;
            const B = py - line1.y;
            const C = line2.x - line1.x;
            const D = line2.y - line1.y;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            if (lenSq !== 0) param = dot / lenSq;

            let xx, yy;
            if (param < 0) {
                xx = line1.x;
                yy = line1.y;
            } else if (param > 1) {
                xx = line2.x;
                yy = line2.y;
            } else {
                xx = line1.x + param * C;
                yy = line1.y + param * D;
            }

            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function spawnEnemy(type, waveBonus = 0) {
            const enemyData = enemyTypes[type];
            const enemy = {
                x: path[0].x,
                y: path[0].y,
                pathIndex: 0,
                hp: enemyData.hp + waveBonus * 20,
                maxHp: enemyData.hp + waveBonus * 20,
                speed: enemyData.speed,
                color: enemyData.color,
                reward: enemyData.reward,
                size: enemyData.size,
                type: type,
                effects: {},
                lastTeleport: 0,
                rushActivated: false,
                barrier: enemyData.barrier || 0,
                groupId: Math.random() // Áæ§„ÇåÁßªÂãïÁî®ID
            };

            // ÁâπÊÆäËÉΩÂäõ„ÅÆÂàùÊúüÂåñ
            if (enemyData.armor) enemy.armor = enemyData.armor;
            if (enemyData.laserWeak) enemy.laserWeak = true;
            if (enemyData.stealth) enemy.stealth = true;
            if (enemyData.healer) enemy.healer = true;
            if (enemyData.splitter) enemy.splitter = true;
            if (enemyData.shield) enemy.shield = true;
            if (enemyData.teleport) enemy.teleport = true;
            if (enemyData.boss) enemy.boss = true;
            if (enemyData.rush) enemy.rush = true;

            return enemy;
        }

        function updateGame() {
            if (gameOver) return;

            // „Ç≤„Éº„É†ÈÄüÂ∫¶ÈÅ©Áî®
            for (let speedStep = 0; speedStep < gameSpeed; speedStep++) {
                frameCount++;

                // „Ç¶„Çß„Éº„ÉñÁÆ°ÁêÜ„ÅÆÊîπÂñÑ
                if (currentWaveEnemies.length === 0 && enemies.length === 0) {
                    if (waveCountdown <= 0) {
                        currentWave++;
                        waveCountdown = 180; // 3Áßí (60fps * 3)
                        
                        // Ê¨°„ÅÆ„Ç¶„Çß„Éº„Éñ„ÅÆÊïµ„ÇíÊ∫ñÂÇô
                        const enemyCount = Math.min(5 + currentWave * 2, 25);
                        currentWaveEnemies = [];
                        
                        for (let i = 0; i < enemyCount; i++) {
                            let enemyType = 'normal';
                            const rand = Math.random();
                            
                            if (currentWave >= 3) {
                                if (currentWave % 10 === 0) {
                                    enemyType = 'boss';
                                } else if (rand < 0.05) {
                                    enemyType = 'teleport';
                                } else if (rand < 0.1) {
                                    enemyType = 'stealth';
                                } else if (rand < 0.15) {
                                    enemyType = 'healer';
                                } else if (rand < 0.2) {
                                    enemyType = 'splitter';
                                } else if (rand < 0.25) {
                                    enemyType = 'shield';
                                } else if (rand < 0.35) {
                                    enemyType = 'armor';
                                } else if (rand < 0.45) {
                                    enemyType = 'rush';
                                } else if (rand < 0.55) {
                                    enemyType = 'barrier';
                                } else if (rand < 0.7) {
                                    enemyType = 'fast';
                                }
                            } else if (rand < 0.3) {
                                enemyType = 'fast';
                            }
                            
                            currentWaveEnemies.push({
                                spawn: i * 30, // 0.5ÁßíÈñìÈöî
                                type: enemyType
                            });
                        }
                        enemySpawnIndex = 0;
                    } else {
                        waveCountdown--;
                    }
                }
                
                // Êïµ„ÅÆ„Çπ„Éù„Éº„É≥Âá¶ÁêÜ„ÅÆÊîπÂñÑ
                if (currentWaveEnemies.length > 0 && enemySpawnIndex < currentWaveEnemies.length) {
                    const nextEnemy = currentWaveEnemies[enemySpawnIndex];
                    if (frameCount >= nextEnemy.spawn) {
                        const enemy = spawnEnemy(nextEnemy.type, currentWave - 1);
                        enemies.push(enemy);
                        enemySpawnIndex++;
                    }
                }

                // Êïµ„ÅÆÁßªÂãï
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    
                    // ÁâπÊÆäËÉΩÂäõ„ÅÆÂá¶ÁêÜ
                    if (enemy.healer && frameCount % 60 === 0) {
                        // „Éí„Éº„É©„ÉºËÉΩÂäõÔºöÂë®Âõ≤„ÅÆÊïµ„ÇíÂõûÂæ©
                        enemies.forEach(other => {
                            if (other !== enemy) {
                                const dist = Math.sqrt((enemy.x - other.x) ** 2 + (enemy.y - other.y) ** 2);
                                if (dist < 80) {
                                    other.hp = Math.min(other.hp + 20, other.maxHp);
                                }
                            }
                        });
                    }

                    if (enemy.teleport && frameCount - enemy.lastTeleport > 300 && Math.random() < 0.01) {
                        // „ÉÜ„É¨„Éù„Éº„ÉàËÉΩÂäõ
                        const newIndex = Math.min(enemy.pathIndex + 2, path.length - 1);
                        enemy.pathIndex = newIndex;
                        if (newIndex < path.length) {
                            enemy.x = path[newIndex].x;
                            enemy.y = path[newIndex].y;
                        }
                        enemy.lastTeleport = frameCount;
                    }

                    if (enemy.rush && !enemy.rushActivated && enemy.hp < enemy.maxHp * 0.5) {
                        // „É©„ÉÉ„Ç∑„É•ËÉΩÂäõÔºöHPÂçäÂàÜ‰ª•‰∏ã„ÅßÂä†ÈÄü
                        enemy.speed *= 2;
                        enemy.rushActivated = true;
                        enemy.color = '#ff4757';
                    }

                    // „Çπ„É≠„Éº„Ç®„Éï„Çß„ÇØ„Éà„ÅÆÂá¶ÁêÜ
                    let currentSpeed = enemy.speed;
                    if (enemy.effects.slow) {
                        currentSpeed *= 0.5;
                        enemy.effects.slow--;
                        if (enemy.effects.slow <= 0) {
                            delete enemy.effects.slow;
                        }
                    }
                    
                    // Ê¨°„ÅÆÁõÆÊ®ôÁÇπ„ÇíÂèñÂæó
                    if (enemy.pathIndex < path.length - 1) {
                        const target = path[enemy.pathIndex + 1];
                        const dx = target.x - enemy.x;
                        const dy = target.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // ÁõÆÊ®ôÁÇπ„Å´ÂçÅÂàÜËøë„Å•„ÅÑ„Åü„ÇâÊ¨°„ÅÆ„Éù„Ç§„É≥„Éà„Å∏
                        if (distance < 5) {
                            enemy.pathIndex++;
                            // Ê¨°„ÅÆ„Éù„Ç§„É≥„Éà„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà„ÄÅÊ≠£Á¢∫„Å™‰ΩçÁΩÆ„Å´Ë®≠ÂÆö
                            if (enemy.pathIndex < path.length) {
                                const nextTarget = path[enemy.pathIndex];
                                enemy.x = nextTarget.x;
                                enemy.y = nextTarget.y;
                            }
                        } else {
                            // ÁßªÂãïÊñπÂêë„ÇíÊ≠£Ë¶èÂåñ„Åó„Å¶ÁßªÂãï
                            const moveX = (dx / distance) * currentSpeed;
                            const moveY = (dy / distance) * currentSpeed;
                            enemy.x += moveX;
                            enemy.y += moveY;
                        }
                    } else {
                        // „Ç¥„Éº„É´„Å´Âà∞ÈÅî
                        enemies.splice(i, 1);
                        lives--;
                        if (lives <= 0) {
                            gameOver = true;
                        }
                    }
                }

                // „Çø„ÉØ„Éº„ÅÆÊîªÊíÉ
                towers.forEach(tower => {
                    if (frameCount - tower.lastFire >= tower.fireRate) {
                        let target = null;
                        let closestDist = tower.range;

                        enemies.forEach(enemy => {
                            // „Çπ„ÉÜ„É´„ÇπÊïµ„ÅÆÊ§úÂá∫Ôºà„É¨„Éº„Ç∂„Éº„Çø„ÉØ„Éº„ÅÆ„ÅøÂèØËÉΩÔºâ
                            if (enemy.stealth && tower.type !== 'laser') return;
                            
                            const dist = Math.sqrt((tower.x - enemy.x) ** 2 + (tower.y - enemy.y) ** 2);
                            if (dist <= closestDist) {
                                target = enemy;
                                closestDist = dist;
                            }
                        });

                        if (target) {
                            projectiles.push({
                                x: tower.x,
                                y: tower.y,
                                targetX: target.x,
                                targetY: target.y,
                                target: target,
                                damage: tower.damage,
                                speed: tower.projectileSpeed,
                                color: tower.color,
                                type: tower.type,
                                slow: tower.slow
                            });
                            tower.lastFire = frameCount;
                        }
                    }
                });

                // Âºæ‰∏∏„ÅÆÁßªÂãï
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const proj = projectiles[i];
                    const dx = proj.targetX - proj.x;
                    const dy = proj.targetY - proj.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < proj.speed || dist < 10) {
                        // Âºæ‰∏∏„ÅåÁõÆÊ®ô„Å´Âà∞ÈÅî
                        if (proj.target && enemies.includes(proj.target)) {
                            let damage = proj.damage;
                            
                            // Ë£ÖÁî≤„Ç∑„Çπ„ÉÜ„É†
                            if (proj.target.armor && proj.type !== 'laser') {
                                damage *= proj.target.armor;
                            }
                            
                            // „É¨„Éº„Ç∂„ÉºÂº±ÁÇπ„Ç∑„Çπ„ÉÜ„É†
                            if (proj.target.laserWeak && proj.type === 'laser') {
                                damage *= 2;
                            }

                            // „Ç∑„Éº„É´„Éâ„Ç∑„Çπ„ÉÜ„É†ÔºàÂâçÊñπ„Åã„Çâ„ÅÆÊîªÊíÉÁÑ°ÂäπÔºâ
                            if (proj.target.shield) {
                                const enemyAngle = Math.atan2(
                                    path[Math.min(proj.target.pathIndex + 1, path.length - 1)].y - proj.target.y,
                                    path[Math.min(proj.target.pathIndex + 1, path.length - 1)].x - proj.target.x
                                );
                                const attackAngle = Math.atan2(proj.y - proj.target.y, proj.x - proj.target.x);
                                const angleDiff = Math.abs(enemyAngle - attackAngle);
                                
                                if (angleDiff < Math.PI / 2 || angleDiff > 3 * Math.PI / 2) {
                                    damage = 0; // ÂâçÊñπ„Åã„Çâ„ÅÆÊîªÊíÉÁÑ°Âäπ
                                }
                            }

                            // „Éê„É™„Ç¢„Ç∑„Çπ„ÉÜ„É†
                            if (proj.target.barrier > 0) {
                                proj.target.barrier -= damage;
                                if (proj.target.barrier <= 0) {
                                    proj.target.barrier = 0;
                                }
                                damage = 0;
                            } else {
                                proj.target.hp -= damage;
                            }

                            // „Çπ„É≠„Éº„Ç®„Éï„Çß„ÇØ„Éà
                            if (proj.slow) {
                                proj.target.effects.slow = 120; // 2ÁßíÈñì
                            }

                            // Êïµ„ÅÆÊíÉÁ†¥Âá¶ÁêÜ
                            if (proj.target.hp <= 0) {
                                money += proj.target.reward;
                                score += proj.target.reward * 10;
                                
                                // „Çπ„Éó„É™„ÉÉ„Çø„ÉºËÉΩÂäõ
                                if (proj.target.splitter) {
                                    for (let j = 0; j < 2; j++) {
                                        const miniEnemy = spawnEnemy('normal');
                                        miniEnemy.hp = 30;
                                        miniEnemy.maxHp = 30;
                                        miniEnemy.size = 8;
                                        miniEnemy.x = proj.target.x + (Math.random() - 0.5) * 20;
                                        miniEnemy.y = proj.target.y + (Math.random() - 0.5) * 20;
                                        miniEnemy.pathIndex = proj.target.pathIndex;
                                        miniEnemy.reward = 5;
                                        enemies.push(miniEnemy);
                                    }
                                }
                                
                                const enemyIndex = enemies.indexOf(proj.target);
                                if (enemyIndex > -1) {
                                    enemies.splice(enemyIndex, 1);
                                }
                            }
                        }
                        projectiles.splice(i, 1);
                    } else {
                        // Âºæ‰∏∏„ÇíÁßªÂãï
                        proj.x += (dx / dist) * proj.speed;
                        proj.y += (dy / dist) * proj.speed;
                    }
                }
            }

            updateUI();
        }

        function render() {
            // ËÉåÊôØ„Çí„ÇØ„É™„Ç¢
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ÁµåË∑Ø„ÇíÊèèÁîª
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 30;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
